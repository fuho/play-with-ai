<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Floor Leveling Calculator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', sans-serif;
      overscroll-behavior: none;
      margin: 0;
      overflow: hidden;
      background-color: #f3f4f6;
    }
    canvas {
      cursor: crosshair; /* Static crosshair cursor */
      touch-action: none;
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }
    #controlsPanel {
      position: absolute;
      top: 1rem;
      left: 1rem;
      z-index: 10;
      width: 24rem;
      max-height: calc(100vh - 2rem);
      overflow-y: auto;
    }
    #floatingInput {
      position: absolute;
      z-index: 100;
      background-color: white;
      border: 1px solid #ccc;
      padding: 8px;
      border-radius: 6px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      display: none;
    }
    #floatingInput input {
      width: 60px;
      padding: 4px;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-right: 5px;
      text-align: right;
    }
    button, .button-like {
      padding: 8px 16px;
      border-radius: 6px;
      background-color: #3b82f6;
      color: white;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
      border: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    button:hover, .button-like:hover {
      background-color: #2563eb;
    }
    button:disabled {
      background-color: #9ca3af;
      cursor: not-allowed;
    }
    input[type="radio"] {
      margin-right: 5px;
    }
    label {
      margin-right: 15px;
      cursor: pointer;
    }
    #jsonImportText {
      width: 100%;
      min-height: 100px;
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 8px;
      font-family: monospace;
      margin-top: 5px;
    }
    /* Style for dropdowns */
    select {
      margin-top: 0.25rem; /* mt-1 */
      display: block;
      width: 100%;
      padding-left: 0.75rem; /* pl-3 */
      padding-right: 2.5rem; /* pr-10 */
      padding-top: 0.5rem; /* py-2 */
      padding-bottom: 0.5rem; /* py-2 */
      border-width: 1px;
      border-color: #d1d5db; /* border-gray-300 */
      border-radius: 0.375rem; /* rounded-md */
      font-size: 0.875rem; /* sm:text-sm */
      line-height: 1.25rem;
    }
    select:focus {
      outline: 2px solid transparent;
      outline-offset: 2px;
      --tw-ring-color: #4f46e5; /* focus:ring-indigo-500 */
      border-color: #6366f1; /* focus:border-indigo-500 */
      box-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);
    }

  </style>
</head>
<body class="bg-gray-100">

<canvas id="floorCanvas"></canvas>

<div id="controlsPanel" class="space-y-6 bg-white p-6 rounded-lg shadow-md">
  <h1 class="text-2xl font-bold text-gray-800">Floor Leveling Calculator</h1>

  <div>
    <label for="gridSpacingInput" class="block text-sm font-medium text-gray-700">Grid Scale (mm per grid square):</label>
    <input type="number" id="gridSpacingInput" value="100" min="1" step="1" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
    <p class="mt-1 text-xs text-gray-500">Defines the real-world size represented by each square on the visual grid.</p>
  </div>

  <div>
    <span class="block text-sm font-medium text-gray-700 mb-2">Mode:</span>
    <div class="flex flex-wrap gap-x-4 gap-y-2">
      <label class="inline-flex items-center">
        <input type="radio" name="mode" value="selectOrigin" checked class="form-radio h-4 w-4 text-indigo-600">
        <span class="ml-2 text-gray-700">Select Origin</span>
      </label>
      <label class="inline-flex items-center">
        <input type="radio" name="mode" value="drawOutline" class="form-radio h-4 w-4 text-indigo-600">
        <span class="ml-2 text-gray-700">Draw Outline</span>
      </label>
      <label class="inline-flex items-center">
        <input type="radio" name="mode" value="selectMeasurements" class="form-radio h-4 w-4 text-indigo-600">
        <span class="ml-2 text-gray-700">Add/Edit Measurements</span>
      </label>
    </div>
  </div>

  <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
    <div>
      <label for="visualizationSelect" class="block text-sm font-medium text-gray-700">Visualization:</label>
      <select id="visualizationSelect">
        <option value="none">None</option>
        <option value="heightMap">Height Map</option>
        <option value="topographicMap">Topographic Map</option>
        <option value="depthNumbers">Depth Numbers</option>
      </select>
    </div>
    <div>
      <label for="interpolationSelect" class="block text-sm font-medium text-gray-700">Interpolation Method:</label>
      <select id="interpolationSelect">
        <option value="nearestNeighbor">Nearest Neighbor</option>
        <option value="idw">Inverse Distance (IDW)</option>
      </select>
      <p class="mt-1 text-xs text-gray-500">Affects Height Map, Volume, Depth Numbers, Topography.</p>
    </div>
  </div>


  <div class="space-y-2 bg-gray-50 p-4 rounded-md border border-gray-200">
    <h3 class="text-lg font-semibold text-gray-800">Results</h3>
    <p class="text-sm text-gray-600">Cursor Coords: <span id="cursorCoords" class="font-mono">(0, 0)</span></p>
    <p class="text-sm text-gray-600">Area: <span id="areaDisplay" class="font-mono">0.00</span> mÂ²</p>
    <p class="text-sm text-gray-600">Volume Needed: <span id="volumeDisplay" class="font-mono">0.00</span> liters</p>
    <p class="text-xs text-gray-500 italic">(Volume calculated based on highest measurement point and selected interpolation)</p>
  </div>

  <div class="space-y-3">
    <h3 class="text-lg font-semibold text-gray-800">Data Management</h3>
    <button id="exportJsonButton" class="w-full">Copy State to Clipboard (JSON)</button>
    <div>
      <button id="importJsonButton" class="w-full mb-2">Import State from JSON</button>
      <textarea id="jsonImportText" placeholder="Paste JSON state here..."></textarea>
    </div>
    <button id="clearAllButton" class="w-full bg-red-500 hover:bg-red-600">Clear All Data</button>
  </div>
  <div class="space-y-2 bg-blue-50 p-4 rounded-md border border-blue-200">
    <h3 class="text-lg font-semibold text-blue-800">Instructions</h3>
    <ul class="list-disc list-inside text-sm text-blue-700 space-y-1">
      <li>Set grid scale (mm per square).</li>
      <li>Choose 'Select Origin' mode (âž• highlight): Click to place/drag the green origin cross.</li>
      <li>Choose 'Draw Outline' mode (â¬œ highlight): Click intersections to add/drag vertices, right-click to delete. Dashed line shows next segment. Click start to close.</li>
      <li>Choose 'Add/Edit Measurements' mode (ðŸ”´ highlight): Click intersection to add/drag, right-click to delete, click existing to edit height.</li>
      <li>Select Interpolation Method (Nearest Neighbor or smoother IDW).</li>
      <li>Select Visualization (Height Map, Topographic, Depth Numbers).</li>
      <li>Copy/Paste JSON to save/load your work.</li>
    </ul>
  </div>
</div>

<div id="floatingInput">
  <input type="number" id="heightInput" step="1">
  <span class="text-xs text-gray-500">mm</span>
</div>

<script>
  // --- DOM Elements ---
  const canvas = document.getElementById('floorCanvas');
  const ctx = canvas.getContext('2d');
  const controlsPanel = document.getElementById('controlsPanel');
  const gridSpacingInput = document.getElementById('gridSpacingInput');
  const modeRadios = document.querySelectorAll('input[name="mode"]');
  const visualizationSelect = document.getElementById('visualizationSelect');
  const interpolationSelect = document.getElementById('interpolationSelect'); // New dropdown
  const cursorCoordsDisplay = document.getElementById('cursorCoords');
  const areaDisplay = document.getElementById('areaDisplay');
  const volumeDisplay = document.getElementById('volumeDisplay');
  const exportJsonButton = document.getElementById('exportJsonButton');
  const importJsonButton = document.getElementById('importJsonButton');
  const jsonImportText = document.getElementById('jsonImportText');
  const clearAllButton = document.getElementById('clearAllButton');
  const floatingInputDiv = document.getElementById('floatingInput');
  const heightInput = document.getElementById('heightInput');

  // --- State Variables ---
  let gridScale = parseInt(gridSpacingInput.value, 10) || 100;
  let mode = 'selectOrigin';
  let visualization = 'none';
  let interpolationMethod = 'nearestNeighbor'; // 'nearestNeighbor' or 'idw'
  let origin = null; // {x, y} grid coords
  let outlinePoints = []; // [{x, y}, ...] grid coords
  let measurementPoints = []; // [{id, x, y, height}, ...] grid coords
  let nextMeasurementId = 0;
  let selectedMeasurementPoint = null;
  let draggingPoint = null;
  let dragStartCoords = null;
  let isOutlineClosed = false;
  let hoverGridPoint = null;
  let canvasRect = null;
  let lastMousePos = null;
  let isMouseOverCanvas = false;

  // --- Constants ---
  const VISUAL_GRID_SIZE = 20;
  const COLORS = { /* ... colors remain the same ... */
    grid: '#e0e0e0', origin: '#10b981', outline: '#3b82f6', measurement: '#ef4444',
    measurementLabel: '#ffffff', selectionHighlight: '#eab308', heightMapLow: [63, 131, 248],
    heightMapHigh: [239, 68, 68], contourLine: '#4b5563', modeIndicatorOrigin: '#10b981',
    modeIndicatorOutline: '#3b82f6', modeIndicatorMeasurement: '#ef4444',
    depthNumberText: 'rgba(0, 0, 0, 0.6)', rubberBandLine: 'rgba(100, 100, 100, 0.6)',
  };
  const POINT_RADIUS = 5;
  const SELECTION_RING_RADIUS = 10;
  const PLACED_INDICATOR_SIZE = 5;
  const HOVER_INDICATOR_SIZE = 6;
  const CONTOUR_INTERVAL = 10;
  const IDW_POWER = 2; // Power for Inverse Distance Weighting
  const EPSILON = 1e-6; // Small number to prevent division by zero

  // --- Utility Functions --- (No changes)
  function canvasToGrid(canvasX, canvasY) { if (typeof canvasX !== 'number' || typeof canvasY !== 'number' || isNaN(canvasX) || isNaN(canvasY)) { return { x: 0, y: 0 }; } const gridX = Math.round(canvasX / VISUAL_GRID_SIZE); const gridY = Math.round(canvasY / VISUAL_GRID_SIZE); return { x: gridX, y: gridY }; }
  function gridToCanvas(gridX, gridY) { const canvasX = gridX * VISUAL_GRID_SIZE; const canvasY = gridY * VISUAL_GRID_SIZE; return { x: canvasX, y: canvasY }; }
  function gridToReal(gridX, gridY) { if (!origin) return { x: null, y: null }; const realX = (gridX - origin.x) * gridScale; const realY = (origin.y - gridY) * gridScale; return { x: realX, y: realY }; }
  function getMousePos(evt) { if (!canvasRect) return { x: 0, y: 0, snappedX: 0, snappedY: 0 }; const clientX = evt.clientX; const clientY = evt.clientY; const canvasX = clientX - canvasRect.left; const canvasY = clientY - canvasRect.top; const snappedX = Math.round(canvasX / VISUAL_GRID_SIZE) * VISUAL_GRID_SIZE; const snappedY = Math.round(canvasY / VISUAL_GRID_SIZE) * VISUAL_GRID_SIZE; return { x: canvasX, y: canvasY, snappedX: snappedX, snappedY: snappedY }; }
  function findMeasurementPointNear(canvasX, canvasY, threshold = PLACED_INDICATOR_SIZE * 1.5) { for (let i = measurementPoints.length - 1; i >= 0; i--) { const point = measurementPoints[i]; const pointCanvas = gridToCanvas(point.x, point.y); const dx = canvasX - pointCanvas.x; const dy = canvasY - pointCanvas.y; if (Math.sqrt(dx * dx + dy * dy) < threshold) { return { point, index: i }; } } return null; }
  function findOutlineVertexNear(canvasX, canvasY, threshold = PLACED_INDICATOR_SIZE * 1.5) { for (let i = outlinePoints.length - 1; i >= 0; i--) { const point = outlinePoints[i]; const pointCanvas = gridToCanvas(point.x, point.y); const dx = canvasX - pointCanvas.x; const dy = canvasY - pointCanvas.y; if (Math.sqrt(dx * dx + dy * dy) < threshold) { return { point, index: i }; } } return null; }
  function isNearOrigin(canvasX, canvasY, threshold = PLACED_INDICATOR_SIZE * 1.5) { if (!origin) return false; const originCanvas = gridToCanvas(origin.x, origin.y); const dx = canvasX - originCanvas.x; const dy = canvasY - originCanvas.y; return Math.sqrt(dx * dx + dy * dy) < threshold; }

  // --- Interpolation Functions ---

  // Nearest Neighbor: Find closest point and return its height
  function getNearestNeighborHeight(gridX, gridY) {
    let nearestPoint = null;
    let minDistanceSq = Infinity;
    let foundValidPoint = false;

    measurementPoints.forEach(point => {
      if (point.height === undefined || point.height === null) return; // Skip points without height
      foundValidPoint = true;
      const dx = point.x - gridX;
      const dy = point.y - gridY;
      const distanceSq = dx * dx + dy * dy;

      if (distanceSq < minDistanceSq) {
        minDistanceSq = distanceSq;
        nearestPoint = point;
      }
    });
    // Return height or null if no valid points or no nearest found (shouldn't happen if foundValidPoint is true)
    return foundValidPoint && nearestPoint ? nearestPoint.height : null;
  }

  // Inverse Distance Weighting
  function calculateIDWHeight(gridX, gridY, power = IDW_POWER) {
    let weightedHeightSum = 0;
    let weightSum = 0;
    let foundValidPoint = false;

    measurementPoints.forEach(point => {
      if (point.height === undefined || point.height === null) return; // Skip points without height
      foundValidPoint = true;

      const dx = point.x - gridX;
      const dy = point.y - gridY;
      const distanceSq = dx * dx + dy * dy;

      // If the grid point is exactly at a measurement point, return that point's height
      if (distanceSq < EPSILON) {
        weightedHeightSum = point.height;
        weightSum = 1;
        return; // Exit forEach early, we have the exact value
      }

      const distance = Math.sqrt(distanceSq);
      const weight = 1.0 / Math.pow(distance, power);

      weightedHeightSum += weight * point.height;
      weightSum += weight;
    });

    // If we found an exact match earlier, weightSum will be 1
    if (weightSum === 1) {
      return weightedHeightSum; // Return the exact height
    }

    // Avoid division by zero if somehow all points are infinitely far (or no valid points)
    if (weightSum < EPSILON || !foundValidPoint) {
      return null; // Cannot interpolate
    }

    return weightedHeightSum / weightSum;
  }

  // Central function to get height based on selected method
  function getInterpolatedHeight(gridX, gridY) {
    const validPoints = measurementPoints.filter(p => p.height !== undefined && p.height !== null);
    if (validPoints.length === 0) {
      return null; // No data to interpolate from
    }

    if (interpolationMethod === 'idw') {
      return calculateIDWHeight(gridX, gridY);
    } else { // Default to nearestNeighbor
      return getNearestNeighborHeight(gridX, gridY);
    }
  }


  // --- Drawing Functions ---

  function drawGrid() { ctx.strokeStyle = COLORS.grid; ctx.lineWidth = 0.5; ctx.beginPath(); for (let x = 0; x <= canvas.width; x += VISUAL_GRID_SIZE) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); } for (let y = 0; y <= canvas.height; y += VISUAL_GRID_SIZE) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); } ctx.stroke(); }
  function drawOrigin() { if (origin) { const originCanvas = gridToCanvas(origin.x, origin.y); if (originCanvas.x >= 0 && originCanvas.x <= canvas.width && originCanvas.y >= 0 && originCanvas.y <= canvas.height) { const x = originCanvas.x; const y = originCanvas.y; const size = PLACED_INDICATOR_SIZE; ctx.strokeStyle = COLORS.origin; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(x - size, y); ctx.lineTo(x + size, y); ctx.moveTo(x, y - size); ctx.lineTo(x, y + size); ctx.stroke(); ctx.lineWidth = 1; ctx.fillStyle = 'black'; ctx.font = '10px Inter'; ctx.fillText('(0,0)', x + size + 2 , y + size + 2); } } }
  function drawOutline() { if (outlinePoints.length < 1) return; ctx.strokeStyle = COLORS.outline; ctx.lineWidth = 2; ctx.beginPath(); const startCanvas = gridToCanvas(outlinePoints[0].x, outlinePoints[0].y); ctx.moveTo(startCanvas.x, startCanvas.y); for (let i = 1; i < outlinePoints.length; i++) { const pointCanvas = gridToCanvas(outlinePoints[i].x, outlinePoints[i].y); ctx.lineTo(pointCanvas.x, pointCanvas.y); } if (isOutlineClosed && outlinePoints.length > 1) { ctx.lineTo(startCanvas.x, startCanvas.y); } ctx.stroke(); const size = PLACED_INDICATOR_SIZE; ctx.strokeStyle = COLORS.outline; ctx.lineWidth = 2; for (let i = 0; i < outlinePoints.length; i++) { const pointCanvas = gridToCanvas(outlinePoints[i].x, outlinePoints[i].y); ctx.strokeRect(pointCanvas.x - size, pointCanvas.y - size, size * 2, size * 2); } ctx.lineWidth = 1; }
  function drawMeasurementPoints() { measurementPoints.forEach(point => { const pointCanvas = gridToCanvas(point.x, point.y); if (pointCanvas.x >= -SELECTION_RING_RADIUS && pointCanvas.x <= canvas.width + SELECTION_RING_RADIUS && pointCanvas.y >= -SELECTION_RING_RADIUS && pointCanvas.y <= canvas.height + SELECTION_RING_RADIUS) { if (selectedMeasurementPoint && selectedMeasurementPoint.id === point.id) { ctx.strokeStyle = COLORS.selectionHighlight; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(pointCanvas.x, pointCanvas.y, SELECTION_RING_RADIUS, 0, Math.PI * 2); ctx.stroke(); ctx.lineWidth = 1; } ctx.fillStyle = COLORS.measurement; ctx.beginPath(); ctx.arc(pointCanvas.x, pointCanvas.y, PLACED_INDICATOR_SIZE, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'black'; ctx.font = '10px Inter'; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom'; const label = `${point.id}: ${point.height === undefined ? '?' : point.height + 'mm'}`; ctx.fillText(label, pointCanvas.x + PLACED_INDICATOR_SIZE + 2, pointCanvas.y - PLACED_INDICATOR_SIZE - 2); } }); }
  function drawHoverHighlight() { if (hoverGridPoint && !draggingPoint && isMouseOverCanvas) { const existingMeasurement = findMeasurementPointNear(gridToCanvas(hoverGridPoint.x, hoverGridPoint.y).x, gridToCanvas(hoverGridPoint.x, hoverGridPoint.y).y); if (existingMeasurement && (!selectedMeasurementPoint || selectedMeasurementPoint.id !== existingMeasurement.point.id)) { return; } const hoverCanvas = gridToCanvas(hoverGridPoint.x, hoverGridPoint.y); if (hoverCanvas.x >= -HOVER_INDICATOR_SIZE && hoverCanvas.x <= canvas.width + HOVER_INDICATOR_SIZE && hoverCanvas.y >= -HOVER_INDICATOR_SIZE && hoverCanvas.y <= canvas.height + HOVER_INDICATOR_SIZE) { const x = hoverCanvas.x; const y = hoverCanvas.y; const size = HOVER_INDICATOR_SIZE; ctx.lineWidth = 2; switch (mode) { case 'selectOrigin': ctx.strokeStyle = COLORS.modeIndicatorOrigin; ctx.beginPath(); ctx.moveTo(x - size, y); ctx.lineTo(x + size, y); ctx.moveTo(x, y - size); ctx.lineTo(x, y + size); ctx.stroke(); break; case 'drawOutline': ctx.strokeStyle = COLORS.modeIndicatorOutline; ctx.strokeRect(x - size, y - size, size * 2, size * 2); break; case 'selectMeasurements': ctx.strokeStyle = COLORS.modeIndicatorMeasurement; ctx.beginPath(); ctx.arc(x, y, size, 0, Math.PI * 2); ctx.stroke(); break; } ctx.lineWidth = 1; } } }
  function drawRubberBandLine() { if (mode === 'drawOutline' && !isOutlineClosed && outlinePoints.length > 0 && hoverGridPoint && isMouseOverCanvas) { const lastPoint = outlinePoints[outlinePoints.length - 1]; const lastPointCanvas = gridToCanvas(lastPoint.x, lastPoint.y); const hoverCanvas = gridToCanvas(hoverGridPoint.x, hoverGridPoint.y); if (hoverGridPoint.x === lastPoint.x && hoverGridPoint.y === lastPoint.y) return; ctx.save(); ctx.strokeStyle = COLORS.rubberBandLine; ctx.lineWidth = 1; ctx.setLineDash([4, 4]); ctx.beginPath(); ctx.moveTo(lastPointCanvas.x, lastPointCanvas.y); ctx.lineTo(hoverCanvas.x, hoverCanvas.y); ctx.stroke(); ctx.restore(); } }

  // --- Visualization Functions ---

  // Modified drawHeightMap to use getInterpolatedHeight
  function drawHeightMap() {
    const validPoints = measurementPoints.filter(p => p.height !== undefined && p.height !== null);
    if (validPoints.length === 0 || !isOutlineClosed) return;

    // Determine min/max heights from actual data for color scaling
    const heights = validPoints.map(p => p.height);
    const minHeight = Math.min(...heights);
    const maxHeight = Math.max(...heights);
    const heightRange = maxHeight - minHeight;

    const imageData = ctx.createImageData(canvas.width, canvas.height);
    const data = imageData.data;
    const gridOutlinePoints = outlinePoints.map(p => ({ x: p.x, y: p.y }));
    const maxGridX = Math.ceil(canvas.width / VISUAL_GRID_SIZE);
    const maxGridY = Math.ceil(canvas.height / VISUAL_GRID_SIZE);

    for (let gy = 0; gy < maxGridY; gy++) {
      for (let gx = 0; gx < maxGridX; gx++) {
        if (isPointInPolygon(gx + 0.5, gy + 0.5, gridOutlinePoints)) {
          // Use the central interpolation function
          const interpolatedHeight = getInterpolatedHeight(gx + 0.5, gy + 0.5); // Use cell center for interpolation

          if (interpolatedHeight !== null) {
            let ratio = heightRange > 0 ? (interpolatedHeight - minHeight) / heightRange : 0.5;
            ratio = Math.max(0, Math.min(1, ratio)); // Clamp ratio

            const r = Math.round(COLORS.heightMapLow[0] + (COLORS.heightMapHigh[0] - COLORS.heightMapLow[0]) * ratio);
            const g = Math.round(COLORS.heightMapLow[1] + (COLORS.heightMapHigh[1] - COLORS.heightMapLow[1]) * ratio);
            const b = Math.round(COLORS.heightMapLow[2] + (COLORS.heightMapHigh[2] - COLORS.heightMapLow[2]) * ratio);

            const startPixelY = gy * VISUAL_GRID_SIZE;
            const endPixelY = Math.min(startPixelY + VISUAL_GRID_SIZE, canvas.height);
            const startPixelX = gx * VISUAL_GRID_SIZE;
            const endPixelX = Math.min(startPixelX + VISUAL_GRID_SIZE, canvas.width);
            for (let py = Math.floor(startPixelY); py < Math.floor(endPixelY); py++) {
              for (let px = Math.floor(startPixelX); px < Math.floor(endPixelX); px++) {
                const index = (py * canvas.width + px) * 4;
                data[index] = r; data[index + 1] = g; data[index + 2] = b; data[index + 3] = 150;
              }
            }
          }
        }
      }
    }
    const currentSmoothing = ctx.imageSmoothingEnabled; ctx.imageSmoothingEnabled = false;
    ctx.putImageData(imageData, 0, 0); ctx.imageSmoothingEnabled = currentSmoothing;
  }

  // Modified drawTopographicMap to use getInterpolatedHeight
  function drawTopographicMap() {
    const validPoints = measurementPoints.filter(p => p.height !== undefined && p.height !== null);
    if (validPoints.length < 2 || !isOutlineClosed) return; // Need at least 2 points

    // Determine min/max from actual data
    const heights = validPoints.map(p => p.height);
    const minHeight = Math.min(...heights);
    const maxHeight = Math.max(...heights);

    ctx.strokeStyle = COLORS.contourLine; ctx.lineWidth = 1; ctx.font = '8px Inter';
    ctx.fillStyle = COLORS.contourLine; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    const gridOutlinePoints = outlinePoints.map(p => ({ x: p.x, y: p.y }));
    const maxGridX = Math.ceil(canvas.width / VISUAL_GRID_SIZE);
    const maxGridY = Math.ceil(canvas.height / VISUAL_GRID_SIZE);

    for (let level = Math.ceil(minHeight / CONTOUR_INTERVAL) * CONTOUR_INTERVAL; level <= maxHeight; level += CONTOUR_INTERVAL) {
      ctx.beginPath(); let lastPoint = null;
      for (let gy = 0; gy < maxGridY; gy++) {
        for (let gx = 0; gx < maxGridX; gx++) {
          // Get interpolated heights at the corners of the cell
          // Using cell corners (gx, gy), (gx+1, gy), (gx, gy+1) for contour finding
          const h1 = getInterpolatedHeight(gx, gy);
          const h2 = getInterpolatedHeight(gx + 1, gy);
          const h3 = getInterpolatedHeight(gx, gy + 1);

          // Check horizontal segment (gx, gy) to (gx+1, gy)
          if (h1 !== null && h2 !== null && h1 !== h2) {
            if ((h1 >= level && h2 < level) || (h1 < level && h2 >= level)) {
              const ratio = (level - h1) / (h2 - h1);
              const intersectX = gx + ratio; const intersectY = gy;
              if (isPointInPolygon(intersectX, intersectY, gridOutlinePoints)) {
                const canvasPos = gridToCanvas(intersectX, intersectY);
                if (lastPoint && Math.abs(lastPoint.x - canvasPos.x) < VISUAL_GRID_SIZE * 1.5 && Math.abs(lastPoint.y - canvasPos.y) < VISUAL_GRID_SIZE * 1.5) ctx.lineTo(canvasPos.x, canvasPos.y); else ctx.moveTo(canvasPos.x, canvasPos.y);
                lastPoint = canvasPos;
              }
            }
          }

          // Check vertical segment (gx, gy) to (gx, gy+1)
          if (h1 !== null && h3 !== null && h1 !== h3) {
            if ((h1 >= level && h3 < level) || (h1 < level && h3 >= level)) {
              const ratio = (level - h1) / (h3 - h1);
              const intersectX = gx; const intersectY = gy + ratio;
              if (isPointInPolygon(intersectX, intersectY, gridOutlinePoints)) {
                const canvasPos = gridToCanvas(intersectX, intersectY);
                if (lastPoint && Math.abs(lastPoint.x - canvasPos.x) < VISUAL_GRID_SIZE * 1.5 && Math.abs(lastPoint.y - canvasPos.y) < VISUAL_GRID_SIZE * 1.5) ctx.lineTo(canvasPos.x, canvasPos.y); else ctx.moveTo(canvasPos.x, canvasPos.y);
                lastPoint = canvasPos;
              }
            }
          }
        }
      } ctx.stroke();
    }
  }

  // Modified drawDepthNumbers to use getInterpolatedHeight
  function drawDepthNumbers() {
    const validPoints = measurementPoints.filter(p => p.height !== undefined && p.height !== null);
    if (validPoints.length === 0 || !isOutlineClosed) return;

    const heights = validPoints.map(p => p.height);
    const maxHeight = Math.max(...heights);
    const gridOutlinePoints = outlinePoints.map(p => ({ x: p.x, y: p.y }));

    const fontSize = Math.max(8, Math.floor(VISUAL_GRID_SIZE / 2.5));
    ctx.font = `${fontSize}px Inter`; ctx.fillStyle = COLORS.depthNumberText;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    const maxGridX = Math.ceil(canvas.width / VISUAL_GRID_SIZE);
    const maxGridY = Math.ceil(canvas.height / VISUAL_GRID_SIZE);

    for (let gy = 0; gy < maxGridY; gy++) {
      for (let gx = 0; gx < maxGridX; gx++) {
        if (isPointInPolygon(gx + 0.5, gy + 0.5, gridOutlinePoints)) {
          // Use the central interpolation function for cell center height
          const interpolatedHeight = getInterpolatedHeight(gx + 0.5, gy + 0.5);

          if (interpolatedHeight !== null) {
            const depth = maxHeight - interpolatedHeight;
            if (depth > 0) {
              const roundedDepth = Math.round(depth);
              const cellCenterX = (gx + 0.5) * VISUAL_GRID_SIZE;
              const cellCenterY = (gy + 0.5) * VISUAL_GRID_SIZE;
              if (fontSize < VISUAL_GRID_SIZE * 0.8) {
                ctx.fillText(roundedDepth.toString(), cellCenterX, cellCenterY);
              }
            }
          }
        }
      }
    }
  }

  // --- Calculation Functions ---

  function calculateArea() { if (!isOutlineClosed || outlinePoints.length < 3) return 0; let area = 0; for (let i = 0; i < outlinePoints.length; i++) { const p1 = outlinePoints[i]; const p2 = outlinePoints[(i + 1) % outlinePoints.length]; area += (p1.x * p2.y - p2.x * p1.y); } const gridArea = Math.abs(area) / 2; const realArea = gridArea * (gridScale / 1000) * (gridScale / 1000); return realArea; }
  function isPointInPolygon(gridX, gridY, polygonPoints) { let isInside = false; for (let i = 0, j = polygonPoints.length - 1; i < polygonPoints.length; j = i++) { const xi = polygonPoints[i].x, yi = polygonPoints[i].y; const xj = polygonPoints[j].x, yj = polygonPoints[j].y; const intersect = ((yi > gridY) !== (yj > gridY)) && (gridX < (xj - xi) * (gridY - yi) / (yj - yi) + xi); if (intersect) isInside = !isInside; } return isInside; }

  // Modified calculateVolume to use getInterpolatedHeight
  function calculateVolume() {
    const validPoints = measurementPoints.filter(p => p.height !== undefined && p.height !== null);
    if (!isOutlineClosed || validPoints.length === 0) return 0;

    const heights = validPoints.map(p => p.height);
    const maxHeight = Math.max(...heights);

    let totalVolumeMM3 = 0;
    const cellAreaMM2 = gridScale * gridScale;
    const gridOutlinePoints = outlinePoints.map(p => ({ x: p.x, y: p.y }));
    const maxGridX = Math.ceil(canvas.width / VISUAL_GRID_SIZE);
    const maxGridY = Math.ceil(canvas.height / VISUAL_GRID_SIZE);

    for (let gy = 0; gy < maxGridY; gy++) {
      for (let gx = 0; gx < maxGridX; gx++) {
        if (isPointInPolygon(gx + 0.5, gy + 0.5, gridOutlinePoints)) {
          // Use the central interpolation function for cell center height
          const interpolatedHeight = getInterpolatedHeight(gx + 0.5, gy + 0.5);

          if (interpolatedHeight !== null) {
            const heightDifference = maxHeight - interpolatedHeight;
            if (heightDifference > 0) {
              totalVolumeMM3 += heightDifference * cellAreaMM2;
            }
          } else {
            // If interpolation fails (e.g., no points), assume max fill? Or skip?
            // Let's assume max fill for now, consistent with previous behavior
            totalVolumeMM3 += maxHeight * cellAreaMM2;
          }
        }
      }
    }
    const totalVolumeLiters = totalVolumeMM3 / 1000000;
    return totalVolumeLiters;
  }

  // --- Update and Redraw ---

  function updateCalculations() { const area = calculateArea(); const volume = calculateVolume(); areaDisplay.textContent = area.toFixed(2); volumeDisplay.textContent = volume.toFixed(2); }

  function redrawCanvas() {
    if (!canvas || !ctx) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw visualizations using interpolated heights
    if (isOutlineClosed && measurementPoints.filter(p => p.height !== undefined && p.height !== null).length > 0) {
      if (visualization === 'heightMap') drawHeightMap();
      else if (visualization === 'topographicMap') drawTopographicMap();
      else if (visualization === 'depthNumbers') drawDepthNumbers();
    }

    drawGrid(); drawOrigin(); drawOutline(); drawMeasurementPoints();
    drawRubberBandLine(); drawHoverHighlight();
  }

  // --- Floating Input Logic --- (No changes)
  function showFloatingInput(canvasX, canvasY, point = null) { selectedMeasurementPoint = point; heightInput.value = (point && point.height !== undefined) ? point.height : ''; const inputX = canvasRect.left + canvasX + 10; const inputY = canvasRect.top + canvasY + 10; floatingInputDiv.style.left = `${inputX}px`; floatingInputDiv.style.top = `${inputY}px`; floatingInputDiv.style.display = 'block'; heightInput.focus(); heightInput.select(); redrawCanvas(); }
  function hideFloatingInput() { if (floatingInputDiv.style.display !== 'none') { if (selectedMeasurementPoint) { const newHeight = parseInt(heightInput.value, 10); if (!isNaN(newHeight)) selectedMeasurementPoint.height = newHeight; else if (heightInput.value.trim() === '') selectedMeasurementPoint.height = undefined; updateCalculations(); } selectedMeasurementPoint = null; floatingInputDiv.style.display = 'none'; redrawCanvas(); } }
  function handleFloatingInputKey(event) { if (event.key === 'Enter') { event.preventDefault(); hideFloatingInput(); } else if (event.key === 'Escape') { selectedMeasurementPoint = null; floatingInputDiv.style.display = 'none'; redrawCanvas(); } }

  // --- Event Handlers ---

  gridSpacingInput.addEventListener('change', () => { const newScale = parseInt(gridSpacingInput.value, 10); if (newScale >= 1) { gridScale = newScale; updateCalculations(); if (origin && hoverGridPoint) { const realCoords = gridToReal(hoverGridPoint.x, hoverGridPoint.y); cursorCoordsDisplay.textContent = `(${realCoords.x}, ${realCoords.y}) mm`; } else if (origin) { cursorCoordsDisplay.textContent = `(Hover over grid)`; } } else { gridSpacingInput.value = gridScale; } });
  modeRadios.forEach(radio => { radio.addEventListener('change', (e) => { mode = e.target.value; selectedMeasurementPoint = null; hideFloatingInput(); hoverGridPoint = null; redrawCanvas(); }); });
  visualizationSelect.addEventListener('change', (e) => { visualization = e.target.value; redrawCanvas(); });
  // Listener for the new interpolation dropdown
  interpolationSelect.addEventListener('change', (e) => {
    interpolationMethod = e.target.value;
    updateCalculations(); // Volume depends on interpolation
    redrawCanvas(); // Visualizations depend on interpolation
  });

  window.addEventListener('mousemove', (e) => { if (!canvas) return; const pos = getMousePos(e); lastMousePos = { x: pos.x, y: pos.y }; if (draggingPoint) { const currentGridPos = canvasToGrid(pos.snappedX, pos.snappedY); if (currentGridPos && (currentGridPos.x !== draggingPoint.x || currentGridPos.y !== draggingPoint.y)) { draggingPoint.x = currentGridPos.x; draggingPoint.y = currentGridPos.y; updateCalculations(); } const realCoords = gridToReal(currentGridPos.x, currentGridPos.y); cursorCoordsDisplay.textContent = origin ? `(${realCoords.x}, ${realCoords.y}) mm` : `(Origin not set)`; canvas.style.cursor = 'grabbing'; redrawCanvas(); return; } else { canvas.style.cursor = 'crosshair'; } isMouseOverCanvas = (e.target === canvas); if (isMouseOverCanvas) { const gridCoords = canvasToGrid(pos.snappedX, pos.snappedY); const realCoords = gridToReal(gridCoords.x, gridCoords.y); cursorCoordsDisplay.textContent = origin ? `(${realCoords.x}, ${realCoords.y}) mm` : `(Origin not set)`; const currentHoverGridPoint = gridCoords; if (!hoverGridPoint || hoverGridPoint.x !== currentHoverGridPoint.x || hoverGridPoint.y !== currentHoverGridPoint.y) { hoverGridPoint = currentHoverGridPoint; redrawCanvas(); } else { if (mode === 'drawOutline' && !isOutlineClosed && outlinePoints.length > 0) { redrawCanvas(); } } } else { if (hoverGridPoint) { hoverGridPoint = null; redrawCanvas(); } cursorCoordsDisplay.textContent = origin ? `(Off Canvas)` : `(Origin not set)`; } });
  canvas.addEventListener('mouseleave', () => { isMouseOverCanvas = false; if (hoverGridPoint) { hoverGridPoint = null; redrawCanvas(); } lastMousePos = null; });
  canvas.addEventListener('mouseenter', (e) => { isMouseOverCanvas = true; });
  canvas.addEventListener('mousedown', (e) => { if (e.button !== 0) return; const pos = getMousePos(e); let foundPointToDrag = null; if (mode === 'selectOrigin') { if (isNearOrigin(pos.x, pos.y)) { foundPointToDrag = origin; } } else if (mode === 'drawOutline') { const clickedVertexData = findOutlineVertexNear(pos.x, pos.y); if (clickedVertexData) { foundPointToDrag = clickedVertexData.point; } } else if (mode === 'selectMeasurements') { const clickedMeasurementData = findMeasurementPointNear(pos.x, pos.y); if (clickedMeasurementData) { foundPointToDrag = clickedMeasurementData.point; } } if (foundPointToDrag) { draggingPoint = foundPointToDrag; dragStartCoords = { x: pos.x, y: pos.y }; hideFloatingInput(); if (mode === 'selectMeasurements') selectedMeasurementPoint = null; canvas.style.cursor = 'grabbing'; redrawCanvas(); } });
  window.addEventListener('mouseup', (e) => { if (e.button !== 0) return; if (draggingPoint) { const pos = getMousePos(e); const finalGridPos = canvasToGrid(pos.snappedX, pos.snappedY); if (finalGridPos) { draggingPoint.x = finalGridPos.x; draggingPoint.y = finalGridPos.y; } draggingPoint = null; dragStartCoords = null; updateCalculations(); canvas.style.cursor = 'crosshair'; redrawCanvas(); } });
  canvas.addEventListener('click', (e) => { const pos = getMousePos(e); const gridCoords = canvasToGrid(pos.snappedX, pos.snappedY); if (!gridCoords || typeof gridCoords.x !== 'number' || typeof gridCoords.y !== 'number') return; if (dragStartCoords && (Math.abs(pos.x - dragStartCoords.x) > 5 || Math.abs(pos.y - dragStartCoords.y) > 5)) return; const clickedMeasurementData = findMeasurementPointNear(pos.x, pos.y); if (floatingInputDiv.style.display === 'block' && (!clickedMeasurementData || !selectedMeasurementPoint || clickedMeasurementData.point.id !== selectedMeasurementPoint.id)) { hideFloatingInput(); } if (mode === 'selectOrigin') { origin = gridCoords; updateCalculations(); redrawCanvas(); } else if (mode === 'drawOutline') { if (!isOutlineClosed) { if (outlinePoints.length >= 3) { const startPoint = outlinePoints[0]; if (gridCoords.x === startPoint.x && gridCoords.y === startPoint.y) { isOutlineClosed = true; updateCalculations(); redrawCanvas(); return; } } const lastPoint = outlinePoints[outlinePoints.length - 1]; if (!lastPoint || lastPoint.x !== gridCoords.x || lastPoint.y !== gridCoords.y) { outlinePoints.push(gridCoords); if (outlinePoints.length === 3) { const startPoint = outlinePoints[0]; if (gridCoords.x === startPoint.x && gridCoords.y === startPoint.y) { isOutlineClosed = true; outlinePoints.pop(); } } updateCalculations(); redrawCanvas(); } } else { console.log("Outline already closed."); } } else if (mode === 'selectMeasurements') { if (clickedMeasurementData) { showFloatingInput(pos.snappedX, pos.snappedY, clickedMeasurementData.point); } else { const newPoint = { id: `M${nextMeasurementId++}`, x: gridCoords.x, y: gridCoords.y, height: undefined }; measurementPoints.push(newPoint); showFloatingInput(pos.snappedX, pos.snappedY, newPoint); } } });
  canvas.addEventListener('contextmenu', (e) => { e.preventDefault(); const pos = getMousePos(e); if (mode === 'selectMeasurements') { const clickedMeasurementData = findMeasurementPointNear(pos.x, pos.y); if (clickedMeasurementData) { if (selectedMeasurementPoint && selectedMeasurementPoint.id === clickedMeasurementData.point.id) hideFloatingInput(); measurementPoints.splice(clickedMeasurementData.index, 1); updateCalculations(); redrawCanvas(); return; } } else if (mode === 'drawOutline') { const clickedVertexData = findOutlineVertexNear(pos.x, pos.y); if (clickedVertexData) { outlinePoints.splice(clickedVertexData.index, 1); if (outlinePoints.length < 3 || isOutlineClosed) { isOutlineClosed = false; } updateCalculations(); redrawCanvas(); return; } } });
  document.addEventListener('click', (e) => { if (floatingInputDiv.style.display === 'block') { if (!canvas.contains(e.target) && !floatingInputDiv.contains(e.target) && !controlsPanel.contains(e.target)) hideFloatingInput(); } });
  heightInput.addEventListener('keydown', handleFloatingInputKey);
  function getStateAsJson() { const state = { gridScale: gridScale, origin: origin, outlinePoints: outlinePoints, measurementPoints: measurementPoints, isOutlineClosed: isOutlineClosed, nextMeasurementId: nextMeasurementId, interpolationMethod: interpolationMethod /* Save method */ }; return JSON.stringify(state, null, 2); }
  function loadStateFromJson(jsonString) { try { const state = JSON.parse(jsonString); if (!state || typeof state !== 'object') throw new Error("Invalid JSON data."); if (typeof state.gridScale !== 'number' || !Array.isArray(state.outlinePoints) || !Array.isArray(state.measurementPoints)) throw new Error("Missing or invalid core state properties."); gridScale = state.gridScale; origin = state.origin || null; outlinePoints = state.outlinePoints; measurementPoints = state.measurementPoints; isOutlineClosed = state.isOutlineClosed || false; nextMeasurementId = state.nextMeasurementId || (measurementPoints.length > 0 ? Math.max(...measurementPoints.map(p => parseInt(p.id.substring(1), 10))) + 1 : 0); interpolationMethod = state.interpolationMethod || 'nearestNeighbor'; /* Load method */ gridSpacingInput.value = gridScale; modeRadios.forEach(r => r.checked = (r.value === 'selectOrigin')); mode = 'selectOrigin'; visualizationSelect.value = 'none'; visualization = 'none'; interpolationSelect.value = interpolationMethod; /* Update dropdown */ selectedMeasurementPoint = null; draggingPoint = null; hoverGridPoint = null; hideFloatingInput(); resizeCanvas(); jsonImportText.value = ''; alert("State imported successfully!"); } catch (error) { console.error("Failed to import state:", error); alert(`Error importing state: ${error.message}`); } }
  exportJsonButton.addEventListener('click', () => { const jsonState = getStateAsJson(); navigator.clipboard.writeText(jsonState).then(() => alert('State copied to clipboard!')).catch(err => { console.error('Failed to copy state: ', err); alert('Error copying state. See console.'); }); });
  importJsonButton.addEventListener('click', () => { const jsonString = jsonImportText.value.trim(); if (jsonString) loadStateFromJson(jsonString); else alert('Please paste JSON state into the text area first.'); });
  clearAllButton.addEventListener('click', () => { if (confirm("Are you sure you want to clear all data?")) { gridScale = 100; origin = null; outlinePoints = []; measurementPoints = []; nextMeasurementId = 0; selectedMeasurementPoint = null; draggingPoint = null; isOutlineClosed = false; hoverGridPoint = null; lastMousePos = null; isMouseOverCanvas = false; interpolationMethod = 'nearestNeighbor'; /* Reset method */ gridSpacingInput.value = gridScale; modeRadios.forEach(r => r.checked = (r.value === 'selectOrigin')); mode = 'selectOrigin'; visualizationSelect.value = 'none'; visualization = 'none'; interpolationSelect.value = interpolationMethod; /* Reset dropdown */ jsonImportText.value = ''; hideFloatingInput(); updateCalculations(); redrawCanvas(); cursorCoordsDisplay.textContent = '(Origin not set)'; } });

  // --- Initial Setup & Resize ---
  function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; canvasRect = canvas.getBoundingClientRect(); redrawCanvas(); updateCalculations(); }
  resizeCanvas(); window.addEventListener('resize', resizeCanvas);

</script>

</body>
</html>
