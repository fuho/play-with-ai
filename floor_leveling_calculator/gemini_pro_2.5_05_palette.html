<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Floor Leveling Calculator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', sans-serif;
      overscroll-behavior: none;
      margin: 0;
      overflow: hidden;
      background-color: #f3f4f6;
    }
    canvas {
      cursor: crosshair; /* Static crosshair cursor */
      touch-action: none;
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }
    #controlsPanel {
      position: absolute;
      top: 1rem;
      left: 1rem;
      z-index: 10;
      width: 24rem; /* Fixed width */
      max-height: calc(100vh - 2rem);
      overflow-y: auto;
      background-color: white; /* Added background */
      padding: 1.5rem; /* p-6 */
      border-radius: 0.5rem; /* rounded-lg */
      box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); /* shadow-md */
    }
    #floatingInput {
      position: absolute;
      z-index: 100;
      background-color: white;
      border: 1px solid #ccc;
      padding: 8px;
      border-radius: 6px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      display: none;
    }
    #floatingInput input {
      width: 60px;
      padding: 4px;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-right: 5px;
      text-align: right;
    }
    /* General Button Style (shared by tool buttons and others) */
    .btn {
      padding: 8px 12px; /* Adjusted padding */
      border-radius: 6px;
      background-color: #e5e7eb; /* gray-200 default */
      color: #374151; /* gray-700 */
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s, color 0.2s, border-color 0.2s;
      border: 1px solid transparent;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 100%; /* Make tool buttons full width */
      text-align: left;
    }
    .btn:hover {
      background-color: #d1d5db; /* gray-300 */
    }
    .btn:disabled {
      background-color: #e5e7eb;
      color: #9ca3af; /* gray-400 */
      cursor: not-allowed;
    }
    /* Active Tool Button Style */
    .btn.active {
      background-color: #3b82f6; /* blue-500 */
      color: white;
      border-color: #2563eb; /* blue-600 */
    }
    .btn.active:hover {
      background-color: #2563eb; /* blue-600 */
    }
    /* Specific Button Styles (like export/import/clear) */
    .btn-primary { background-color: #3b82f6; color: white; }
    .btn-primary:hover { background-color: #2563eb; }
    .btn-danger { background-color: #ef4444; color: white; }
    .btn-danger:hover { background-color: #dc2626; }

    /* Tool Button Icon Style */
    .btn svg {
      margin-right: 8px;
      width: 16px;
      height: 16px;
      flex-shrink: 0; /* Prevent icon shrinking */
    }

    /* Checkbox styling */
    .checkbox-label {
      display: flex;
      align-items: center;
      cursor: pointer;
      margin-bottom: 0.5rem; /* mb-2 */
    }
    .checkbox-label input[type="checkbox"] {
      margin-right: 0.5rem; /* mr-2 */
      height: 1rem; /* h-4 */
      width: 1rem; /* w-4 */
      border-radius: 0.25rem; /* rounded */
      border-color: #d1d5db; /* border-gray-300 */
      color: #3b82f6; /* text-indigo-600 */
    }
    .checkbox-label input[type="checkbox"]:focus {
      --tw-ring-offset-width: 2px;
      --tw-ring-color: #60a5fa; /* focus:ring-blue-400 */
      box-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
    }


    #jsonImportText { width: 100%; min-height: 100px; border: 1px solid #ccc; border-radius: 6px; padding: 8px; font-family: monospace; margin-top: 5px; }
    select { margin-top: 0.25rem; display: block; width: 100%; padding-left: 0.75rem; padding-right: 2.5rem; padding-top: 0.5rem; padding-bottom: 0.5rem; border-width: 1px; border-color: #d1d5db; border-radius: 0.375rem; font-size: 0.875rem; line-height: 1.25rem; }
    select:focus { outline: 2px solid transparent; outline-offset: 2px; --tw-ring-color: #4f46e5; border-color: #6366f1; box-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color); }

  </style>
</head>
<body class="bg-gray-100">

<canvas id="floorCanvas"></canvas>

<div id="controlsPanel" class="space-y-6">
  <h1 class="text-2xl font-bold text-gray-800">Floor Leveling Calculator</h1>

  <div>
    <label for="gridSpacingInput" class="block text-sm font-medium text-gray-700">Grid Scale (mm per grid square):</label>
    <input type="number" id="gridSpacingInput" value="100" min="1" step="1" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
    <p class="mt-1 text-xs text-gray-500">Defines the real-world size represented by each square on the visual grid.</p>
  </div>

  <div>
    <span class="block text-sm font-medium text-gray-700 mb-2">Tools:</span>
    <div id="toolPalette" class="flex flex-col space-y-1">
      <button class="btn active" data-mode="selectMove">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M14.082 2.182a.5.5 0 0 1 .103.557L8.528 15.467a.5.5 0 0 1-.917-.007L5.57 10.694.803 8.652a.5.5 0 0 1-.006-.916l12.728-5.657a.5.5 0 0 1 .556.103z"/></svg>
        Select / Move
      </button>
      <button class="btn" data-mode="selectOrigin">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/></svg>
        Set Origin
      </button>
      <button class="btn" data-mode="drawOutline">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M0 1a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V1zm15 0a.5.5 0 0 0-.5-.5H1.5A.5.5 0 0 0 1 .5v14a.5.5 0 0 0 .5.5h14a.5.5 0 0 0 .5-.5V1z"/></svg>
        Draw Outline
      </button>
      <button class="btn" data-mode="selectMeasurements">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/></svg>
        Add/Edit Measurements
      </button>
    </div>
  </div>

  <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
    <div>
      <label for="interpolationSelect" class="block text-sm font-medium text-gray-700">Interpolation:</label>
      <select id="interpolationSelect">
        <option value="nearestNeighbor">Nearest Neighbor</option>
        <option value="idw">Inverse Distance (IDW)</option>
      </select>
      <p class="mt-1 text-xs text-gray-500">Smoothness for visuals & volume.</p>
    </div>
    <div>
      <span class="block text-sm font-medium text-gray-700 mb-2">Visualizations:</span>
      <div id="visualizationCheckboxes">
        <label class="checkbox-label">
          <input type="checkbox" value="heightMap">
          <span class="ml-2 text-gray-700 text-sm">Height Map</span>
        </label>
        <label class="checkbox-label">
          <input type="checkbox" value="depthNumbers">
          <span class="ml-2 text-gray-700 text-sm">Depth Numbers</span>
        </label>
        <label class="checkbox-label">
          <input type="checkbox" value="topographicMap">
          <span class="ml-2 text-gray-700 text-sm">Topographic Map</span>
        </label>
      </div>
    </div>
  </div>


  <div class="space-y-2 bg-gray-50 p-4 rounded-md border border-gray-200">
    <h3 class="text-lg font-semibold text-gray-800">Results</h3>
    <p class="text-sm text-gray-600">Cursor Coords: <span id="cursorCoords" class="font-mono">(0, 0)</span></p>
    <p class="text-sm text-gray-600">Area: <span id="areaDisplay" class="font-mono">0.00</span> mÂ²</p>
    <p class="text-sm text-gray-600">Volume Needed: <span id="volumeDisplay" class="font-mono">0.00</span> liters</p>
    <p class="text-xs text-gray-500 italic">(Volume based on highest point & interpolation)</p>
  </div>

  <div class="space-y-3">
    <h3 class="text-lg font-semibold text-gray-800">Data Management</h3>
    <button id="exportJsonButton" class="btn btn-primary w-full">Copy State to Clipboard (JSON)</button>
    <div>
      <button id="importJsonButton" class="btn btn-primary w-full mb-2">Import State from JSON</button>
      <textarea id="jsonImportText" placeholder="Paste JSON state here..."></textarea>
    </div>
    <button id="clearAllButton" class="btn btn-danger w-full">Clear All Data</button>
  </div>
  <div class="space-y-2 bg-blue-50 p-4 rounded-md border border-blue-200">
    <h3 class="text-lg font-semibold text-blue-800">Instructions</h3>
    <ul class="list-disc list-inside text-sm text-blue-700 space-y-1">
      <li>Set Grid Scale.</li>
      <li>Use Tools:
        <ul>
          <li><span class="font-bold">Select/Move (Default):</span> Click & drag any point (origin, outline, measurement).</li>
          <li><span class="font-bold">Set Origin:</span> Click to place origin. Drag existing origin.</li>
          <li><span class="font-bold">Draw Outline:</span> Click to add vertices. Drag vertices. Right-click vertex to delete. Click start vertex to close.</li>
          <li><span class="font-bold">Add/Edit Measurements:</span> Click empty spot to add. Click existing point to edit height. Drag points. Right-click point to delete.</li>
        </ul>
      </li>
      <li>Select Interpolation method.</li>
      <li>Check desired Visualizations (can be layered).</li>
      <li>Copy/Paste JSON to save/load.</li>
    </ul>
  </div>
</div>

<div id="floatingInput">
  <input type="number" id="heightInput" step="1">
  <span class="text-xs text-gray-500">mm</span>
</div>

<script>
  // --- DOM Elements ---
  const canvas = document.getElementById('floorCanvas');
  const ctx = canvas.getContext('2d');
  const controlsPanel = document.getElementById('controlsPanel');
  const gridSpacingInput = document.getElementById('gridSpacingInput');
  const toolPalette = document.getElementById('toolPalette');
  const visualizationCheckboxesContainer = document.getElementById('visualizationCheckboxes');
  const visualizationCheckboxes = visualizationCheckboxesContainer.querySelectorAll('input[type="checkbox"]');
  const interpolationSelect = document.getElementById('interpolationSelect');
  const cursorCoordsDisplay = document.getElementById('cursorCoords');
  const areaDisplay = document.getElementById('areaDisplay');
  const volumeDisplay = document.getElementById('volumeDisplay');
  const exportJsonButton = document.getElementById('exportJsonButton');
  const importJsonButton = document.getElementById('importJsonButton');
  const jsonImportText = document.getElementById('jsonImportText');
  const clearAllButton = document.getElementById('clearAllButton');
  const floatingInputDiv = document.getElementById('floatingInput');
  const heightInput = document.getElementById('heightInput');

  // --- State Variables ---
  let gridScale = parseInt(gridSpacingInput.value, 10) || 100;
  let mode = 'selectMove';
  let activeVisualizations = new Set();
  let interpolationMethod = 'nearestNeighbor';
  let origin = null;
  let outlinePoints = [];
  let measurementPoints = [];
  let nextMeasurementId = 0;
  let selectedMeasurementPoint = null;
  let draggingPoint = null;
  let dragStartCoords = null;
  let isOutlineClosed = false;
  let hoverGridPoint = null;
  let hoverSpecificPoint = null;
  let canvasRect = null;
  let lastMousePos = null;
  let isMouseOverCanvas = false;

  // --- Constants ---
  const VISUAL_GRID_SIZE = 20;
  const COLORS = {
    grid: '#d1d5db', // Made grid slightly darker gray-300
    origin: '#10b981', outline: '#3b82f6', measurement: '#ef4444',
    measurementLabel: '#ffffff', selectionHighlight: '#eab308', heightMapLow: [63, 131, 248],
    heightMapHigh: [239, 68, 68], contourLine: '#4b5563', modeIndicatorOrigin: '#10b981',
    modeIndicatorOutline: '#3b82f6', modeIndicatorMeasurement: '#ef4444',
    depthNumberText: 'rgba(0, 0, 0, 0.6)', rubberBandLine: 'rgba(100, 100, 100, 0.6)',
    hoverSpecificPointHighlight: 'rgba(249, 115, 22, 0.5)',
  };
  const POINT_RADIUS = 5;
  const SELECTION_RING_RADIUS = 10;
  const PLACED_INDICATOR_SIZE = 5;
  const HOVER_INDICATOR_SIZE = 6;
  const HOVER_POINT_RING_RADIUS = 8;
  const CONTOUR_INTERVAL = 1;
  const IDW_POWER = 2;
  const EPSILON = 1e-6;

  // --- Utility Functions --- (No changes)
  function canvasToGrid(canvasX, canvasY) { if (typeof canvasX !== 'number' || typeof canvasY !== 'number' || isNaN(canvasX) || isNaN(canvasY)) { return { x: 0, y: 0 }; } const gridX = Math.round(canvasX / VISUAL_GRID_SIZE); const gridY = Math.round(canvasY / VISUAL_GRID_SIZE); return { x: gridX, y: gridY }; }
  function gridToCanvas(gridX, gridY) { const canvasX = gridX * VISUAL_GRID_SIZE; const canvasY = gridY * VISUAL_GRID_SIZE; return { x: canvasX, y: canvasY }; }
  function gridToReal(gridX, gridY) { if (!origin) return { x: null, y: null }; const realX = (gridX - origin.x) * gridScale; const realY = (origin.y - gridY) * gridScale; return { x: realX, y: realY }; }
  function getMousePos(evt) { if (!canvasRect) return { x: 0, y: 0, snappedX: 0, snappedY: 0 }; const clientX = evt.clientX; const clientY = evt.clientY; const canvasX = clientX - canvasRect.left; const canvasY = clientY - canvasRect.top; const snappedX = Math.round(canvasX / VISUAL_GRID_SIZE) * VISUAL_GRID_SIZE; const snappedY = Math.round(canvasY / VISUAL_GRID_SIZE) * VISUAL_GRID_SIZE; return { x: canvasX, y: canvasY, snappedX: snappedX, snappedY: snappedY }; }
  function findMeasurementPointNear(canvasX, canvasY, threshold = PLACED_INDICATOR_SIZE * 1.5) { for (let i = measurementPoints.length - 1; i >= 0; i--) { const point = measurementPoints[i]; const pointCanvas = gridToCanvas(point.x, point.y); const dx = canvasX - pointCanvas.x; const dy = canvasY - pointCanvas.y; if (Math.sqrt(dx * dx + dy * dy) < threshold) { return { point, index: i }; } } return null; }
  function findOutlineVertexNear(canvasX, canvasY, threshold = PLACED_INDICATOR_SIZE * 1.5) { for (let i = outlinePoints.length - 1; i >= 0; i--) { const point = outlinePoints[i]; const pointCanvas = gridToCanvas(point.x, point.y); const dx = canvasX - pointCanvas.x; const dy = canvasY - pointCanvas.y; if (Math.sqrt(dx * dx + dy * dy) < threshold) { return { point, index: i }; } } return null; }
  function isNearOrigin(canvasX, canvasY, threshold = PLACED_INDICATOR_SIZE * 1.5) { if (!origin) return false; const originCanvas = gridToCanvas(origin.x, origin.y); const dx = canvasX - originCanvas.x; const dy = canvasY - originCanvas.y; return Math.sqrt(dx * dx + dy * dy) < threshold; }

  // --- Interpolation Functions --- (No changes)
  function getNearestNeighborHeight(gridX, gridY) { let nearestPoint = null; let minDistanceSq = Infinity; let foundValidPoint = false; measurementPoints.forEach(point => { if (point.height === undefined || point.height === null) return; foundValidPoint = true; const dx = point.x - gridX; const dy = point.y - gridY; const distanceSq = dx * dx + dy * dy; if (distanceSq < minDistanceSq) { minDistanceSq = distanceSq; nearestPoint = point; } }); return foundValidPoint && nearestPoint ? nearestPoint.height : null; }
  function calculateIDWHeight(gridX, gridY, power = IDW_POWER) { let weightedHeightSum = 0; let weightSum = 0; let foundValidPoint = false; measurementPoints.forEach(point => { if (point.height === undefined || point.height === null) return; foundValidPoint = true; const dx = point.x - gridX; const dy = point.y - gridY; const distanceSq = dx * dx + dy * dy; if (distanceSq < EPSILON) { weightedHeightSum = point.height; weightSum = 1; return; } const distance = Math.sqrt(distanceSq); const weight = 1.0 / Math.pow(distance, power); weightedHeightSum += weight * point.height; weightSum += weight; }); if (weightSum === 1) { return weightedHeightSum; } if (weightSum < EPSILON || !foundValidPoint) { return null; } return weightedHeightSum / weightSum; }
  function getInterpolatedHeight(gridX, gridY) { const validPoints = measurementPoints.filter(p => p.height !== undefined && p.height !== null); if (validPoints.length === 0) { return null; } if (interpolationMethod === 'idw') { return calculateIDWHeight(gridX, gridY); } else { return getNearestNeighborHeight(gridX, gridY); } }

  // --- Drawing Functions ---

  // Modified drawGrid - increased lineWidth and changed color slightly
  function drawGrid() {
    ctx.strokeStyle = COLORS.grid; // Slightly darker gray
    ctx.lineWidth = 1; // Use 1 instead of 0.5
    ctx.beginPath();
    for (let x = 0; x <= canvas.width; x += VISUAL_GRID_SIZE) {
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
    }
    for (let y = 0; y <= canvas.height; y += VISUAL_GRID_SIZE) {
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
    }
    ctx.stroke();
    ctx.lineWidth = 1; // Reset just in case
  }

  function drawOrigin() { if (origin) { const originCanvas = gridToCanvas(origin.x, origin.y); if (originCanvas.x >= 0 && originCanvas.x <= canvas.width && originCanvas.y >= 0 && originCanvas.y <= canvas.height) { const x = originCanvas.x; const y = originCanvas.y; const size = PLACED_INDICATOR_SIZE; ctx.strokeStyle = COLORS.origin; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(x - size, y); ctx.lineTo(x + size, y); ctx.moveTo(x, y - size); ctx.lineTo(x, y + size); ctx.stroke(); ctx.lineWidth = 1; ctx.fillStyle = 'black'; ctx.font = '10px Inter'; ctx.fillText('(0,0)', x + size + 2 , y + size + 2); } } }
  function drawOutline() { if (outlinePoints.length < 1) return; ctx.strokeStyle = COLORS.outline; ctx.lineWidth = 2; ctx.beginPath(); const startCanvas = gridToCanvas(outlinePoints[0].x, outlinePoints[0].y); ctx.moveTo(startCanvas.x, startCanvas.y); for (let i = 1; i < outlinePoints.length; i++) { const pointCanvas = gridToCanvas(outlinePoints[i].x, outlinePoints[i].y); ctx.lineTo(pointCanvas.x, pointCanvas.y); } if (isOutlineClosed && outlinePoints.length > 1) { ctx.lineTo(startCanvas.x, startCanvas.y); } ctx.stroke(); const size = PLACED_INDICATOR_SIZE; ctx.strokeStyle = COLORS.outline; ctx.lineWidth = 2; for (let i = 0; i < outlinePoints.length; i++) { const pointCanvas = gridToCanvas(outlinePoints[i].x, outlinePoints[i].y); ctx.strokeRect(pointCanvas.x - size, pointCanvas.y - size, size * 2, size * 2); } ctx.lineWidth = 1; }
  function drawMeasurementPoints() { measurementPoints.forEach(point => { const pointCanvas = gridToCanvas(point.x, point.y); if (pointCanvas.x >= -SELECTION_RING_RADIUS && pointCanvas.x <= canvas.width + SELECTION_RING_RADIUS && pointCanvas.y >= -SELECTION_RING_RADIUS && pointCanvas.y <= canvas.height + SELECTION_RING_RADIUS) { if (selectedMeasurementPoint && selectedMeasurementPoint.id === point.id) { ctx.strokeStyle = COLORS.selectionHighlight; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(pointCanvas.x, pointCanvas.y, SELECTION_RING_RADIUS, 0, Math.PI * 2); ctx.stroke(); ctx.lineWidth = 1; } ctx.fillStyle = COLORS.measurement; ctx.beginPath(); ctx.arc(pointCanvas.x, pointCanvas.y, PLACED_INDICATOR_SIZE, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'black'; ctx.font = '10px Inter'; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom'; const label = `${point.id}: ${point.height === undefined ? '?' : point.height + 'mm'}`; ctx.fillText(label, pointCanvas.x + PLACED_INDICATOR_SIZE + 2, pointCanvas.y - PLACED_INDICATOR_SIZE - 2); } }); }
  function drawHoverHighlight() { if (!isMouseOverCanvas || draggingPoint) { hoverSpecificPoint = null; return; } if (mode === 'selectMove' && lastMousePos) { hoverSpecificPoint = null; let foundHover = false; const measurement = findMeasurementPointNear(lastMousePos.x, lastMousePos.y, HOVER_POINT_RING_RADIUS); if (measurement) { hoverSpecificPoint = measurement.point; foundHover = true; } if (!foundHover) { const outlineVtx = findOutlineVertexNear(lastMousePos.x, lastMousePos.y, HOVER_POINT_RING_RADIUS); if (outlineVtx) { hoverSpecificPoint = outlineVtx.point; foundHover = true; } } if (!foundHover && isNearOrigin(lastMousePos.x, lastMousePos.y, HOVER_POINT_RING_RADIUS)) { hoverSpecificPoint = origin; foundHover = true; } if (hoverSpecificPoint) { const pointCanvas = gridToCanvas(hoverSpecificPoint.x, hoverSpecificPoint.y); ctx.strokeStyle = COLORS.hoverSpecificPointHighlight; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(pointCanvas.x, pointCanvas.y, HOVER_POINT_RING_RADIUS, 0, Math.PI * 2); ctx.stroke(); ctx.lineWidth = 1; return; } } else { hoverSpecificPoint = null; } if (hoverGridPoint) { const existingMeasurement = findMeasurementPointNear(gridToCanvas(hoverGridPoint.x, hoverGridPoint.y).x, gridToCanvas(hoverGridPoint.x, hoverGridPoint.y).y); if (existingMeasurement && (!selectedMeasurementPoint || selectedMeasurementPoint.id !== existingMeasurement.point.id)) { return; } const hoverCanvas = gridToCanvas(hoverGridPoint.x, hoverGridPoint.y); if (hoverCanvas.x >= -HOVER_INDICATOR_SIZE && hoverCanvas.x <= canvas.width + HOVER_INDICATOR_SIZE && hoverCanvas.y >= -HOVER_INDICATOR_SIZE && hoverCanvas.y <= canvas.height + HOVER_INDICATOR_SIZE) { const x = hoverCanvas.x; const y = hoverCanvas.y; const size = HOVER_INDICATOR_SIZE; ctx.lineWidth = 2; switch (mode) { case 'selectOrigin': ctx.strokeStyle = COLORS.modeIndicatorOrigin; ctx.beginPath(); ctx.moveTo(x - size, y); ctx.lineTo(x + size, y); ctx.moveTo(x, y - size); ctx.lineTo(x, y + size); ctx.stroke(); break; case 'drawOutline': ctx.strokeStyle = COLORS.modeIndicatorOutline; ctx.strokeRect(x - size, y - size, size * 2, size * 2); break; case 'selectMeasurements': ctx.strokeStyle = COLORS.modeIndicatorMeasurement; ctx.beginPath(); ctx.arc(x, y, size, 0, Math.PI * 2); ctx.stroke(); break; } ctx.lineWidth = 1; } } }
  function drawRubberBandLine() { if (mode === 'drawOutline' && !isOutlineClosed && outlinePoints.length > 0 && hoverGridPoint && isMouseOverCanvas) { const lastPoint = outlinePoints[outlinePoints.length - 1]; const lastPointCanvas = gridToCanvas(lastPoint.x, lastPoint.y); const hoverCanvas = gridToCanvas(hoverGridPoint.x, hoverGridPoint.y); if (hoverGridPoint.x === lastPoint.x && hoverGridPoint.y === lastPoint.y) return; ctx.save(); ctx.strokeStyle = COLORS.rubberBandLine; ctx.lineWidth = 1; ctx.setLineDash([4, 4]); ctx.beginPath(); ctx.moveTo(lastPointCanvas.x, lastPointCanvas.y); ctx.lineTo(hoverCanvas.x, hoverCanvas.y); ctx.stroke(); ctx.restore(); } }

  // --- Visualization Functions --- (No changes)
  function drawHeightMap() { const validPoints = measurementPoints.filter(p => p.height !== undefined && p.height !== null); if (validPoints.length === 0 || !isOutlineClosed) return; const heights = validPoints.map(p => p.height); const minHeight = Math.min(...heights); const maxHeight = Math.max(...heights); const heightRange = maxHeight - minHeight; const imageData = ctx.createImageData(canvas.width, canvas.height); const data = imageData.data; const gridOutlinePoints = outlinePoints.map(p => ({ x: p.x, y: p.y })); const maxGridX = Math.ceil(canvas.width / VISUAL_GRID_SIZE); const maxGridY = Math.ceil(canvas.height / VISUAL_GRID_SIZE); for (let gy = 0; gy < maxGridY; gy++) { for (let gx = 0; gx < maxGridX; gx++) { if (isPointInPolygon(gx + 0.5, gy + 0.5, gridOutlinePoints)) { const interpolatedHeight = getInterpolatedHeight(gx + 0.5, gy + 0.5); if (interpolatedHeight !== null) { let ratio = heightRange > 0 ? (interpolatedHeight - minHeight) / heightRange : 0.5; ratio = Math.max(0, Math.min(1, ratio)); const r = Math.round(COLORS.heightMapLow[0] + (COLORS.heightMapHigh[0] - COLORS.heightMapLow[0]) * ratio); const g = Math.round(COLORS.heightMapLow[1] + (COLORS.heightMapHigh[1] - COLORS.heightMapLow[1]) * ratio); const b = Math.round(COLORS.heightMapLow[2] + (COLORS.heightMapHigh[2] - COLORS.heightMapLow[2]) * ratio); const startPixelY = gy * VISUAL_GRID_SIZE; const endPixelY = Math.min(startPixelY + VISUAL_GRID_SIZE, canvas.height); const startPixelX = gx * VISUAL_GRID_SIZE; const endPixelX = Math.min(startPixelX + VISUAL_GRID_SIZE, canvas.width); for (let py = Math.floor(startPixelY); py < Math.floor(endPixelY); py++) { for (let px = Math.floor(startPixelX); px < Math.floor(endPixelX); px++) { const index = (py * canvas.width + px) * 4; data[index] = r; data[index + 1] = g; data[index + 2] = b; data[index + 3] = 150; } } } } } } const currentSmoothing = ctx.imageSmoothingEnabled; ctx.imageSmoothingEnabled = false; ctx.putImageData(imageData, 0, 0); ctx.imageSmoothingEnabled = currentSmoothing; }
  function drawTopographicMap() { const validPoints = measurementPoints.filter(p => p.height !== undefined && p.height !== null); if (validPoints.length < 2 || !isOutlineClosed) return; const heights = validPoints.map(p => p.height); const minHeight = Math.min(...heights); const maxHeight = Math.max(...heights); ctx.strokeStyle = COLORS.contourLine; ctx.lineWidth = 1; ctx.font = '8px Inter'; ctx.fillStyle = COLORS.contourLine; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const gridOutlinePoints = outlinePoints.map(p => ({ x: p.x, y: p.y })); const maxGridX = Math.ceil(canvas.width / VISUAL_GRID_SIZE); const maxGridY = Math.ceil(canvas.height / VISUAL_GRID_SIZE); for (let level = Math.ceil(minHeight / CONTOUR_INTERVAL) * CONTOUR_INTERVAL; level <= maxHeight; level += CONTOUR_INTERVAL) { ctx.beginPath(); let lastPoint = null; for (let gy = 0; gy < maxGridY; gy++) { for (let gx = 0; gx < maxGridX; gx++) { const h1 = getInterpolatedHeight(gx, gy); const h2 = getInterpolatedHeight(gx + 1, gy); if (h1 !== null && h2 !== null && h1 !== h2) { if ((h1 >= level && h2 < level) || (h1 < level && h2 >= level)) { const ratio = (level - h1) / (h2 - h1); const intersectX = gx + ratio; const intersectY = gy; if (isPointInPolygon(intersectX, intersectY, gridOutlinePoints)) { const canvasPos = gridToCanvas(intersectX, intersectY); if (lastPoint && Math.abs(lastPoint.x - canvasPos.x) < VISUAL_GRID_SIZE * 1.5 && Math.abs(lastPoint.y - canvasPos.y) < VISUAL_GRID_SIZE * 1.5) ctx.lineTo(canvasPos.x, canvasPos.y); else ctx.moveTo(canvasPos.x, canvasPos.y); lastPoint = canvasPos; } } } const h3 = getInterpolatedHeight(gx, gy + 1); if (h1 !== null && h3 !== null && h1 !== h3) { if ((h1 >= level && h3 < level) || (h1 < level && h3 >= level)) { const ratio = (level - h1) / (h3 - h1); const intersectX = gx; const intersectY = gy + ratio; if (isPointInPolygon(intersectX, intersectY, gridOutlinePoints)) { const canvasPos = gridToCanvas(intersectX, intersectY); if (lastPoint && Math.abs(lastPoint.x - canvasPos.x) < VISUAL_GRID_SIZE * 1.5 && Math.abs(lastPoint.y - canvasPos.y) < VISUAL_GRID_SIZE * 1.5) ctx.lineTo(canvasPos.x, canvasPos.y); else ctx.moveTo(canvasPos.x, canvasPos.y); lastPoint = canvasPos; } } } } } ctx.stroke(); } }
  function drawDepthNumbers() { const validPoints = measurementPoints.filter(p => p.height !== undefined && p.height !== null); if (validPoints.length === 0 || !isOutlineClosed) return; const heights = validPoints.map(p => p.height); const maxHeight = Math.max(...heights); const gridOutlinePoints = outlinePoints.map(p => ({ x: p.x, y: p.y })); const fontSize = Math.max(8, Math.floor(VISUAL_GRID_SIZE / 2.5)); ctx.font = `${fontSize}px Inter`; ctx.fillStyle = COLORS.depthNumberText; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const maxGridX = Math.ceil(canvas.width / VISUAL_GRID_SIZE); const maxGridY = Math.ceil(canvas.height / VISUAL_GRID_SIZE); for (let gy = 0; gy < maxGridY; gy++) { for (let gx = 0; gx < maxGridX; gx++) { if (isPointInPolygon(gx + 0.5, gy + 0.5, gridOutlinePoints)) { const interpolatedHeight = getInterpolatedHeight(gx + 0.5, gy + 0.5); if (interpolatedHeight !== null) { const depth = maxHeight - interpolatedHeight; if (depth > 0) { const roundedDepth = Math.round(depth); const cellCenterX = (gx + 0.5) * VISUAL_GRID_SIZE; const cellCenterY = (gy + 0.5) * VISUAL_GRID_SIZE; if (fontSize < VISUAL_GRID_SIZE * 0.8) { ctx.fillText(roundedDepth.toString(), cellCenterX, cellCenterY); } } } } } } }

  // --- Calculation Functions --- (No changes)
  function calculateArea() { if (!isOutlineClosed || outlinePoints.length < 3) return 0; let area = 0; for (let i = 0; i < outlinePoints.length; i++) { const p1 = outlinePoints[i]; const p2 = outlinePoints[(i + 1) % outlinePoints.length]; area += (p1.x * p2.y - p2.x * p1.y); } const gridArea = Math.abs(area) / 2; const realArea = gridArea * (gridScale / 1000) * (gridScale / 1000); return realArea; }
  function isPointInPolygon(gridX, gridY, polygonPoints) { let isInside = false; for (let i = 0, j = polygonPoints.length - 1; i < polygonPoints.length; j = i++) { const xi = polygonPoints[i].x, yi = polygonPoints[i].y; const xj = polygonPoints[j].x, yj = polygonPoints[j].y; const intersect = ((yi > gridY) !== (yj > gridY)) && (gridX < (xj - xi) * (gridY - yi) / (yj - yi) + xi); if (intersect) isInside = !isInside; } return isInside; }
  function calculateVolume() { const validPoints = measurementPoints.filter(p => p.height !== undefined && p.height !== null); if (!isOutlineClosed || validPoints.length === 0) return 0; const heights = validPoints.map(p => p.height); const maxHeight = Math.max(...heights); let totalVolumeMM3 = 0; const cellAreaMM2 = gridScale * gridScale; const gridOutlinePoints = outlinePoints.map(p => ({ x: p.x, y: p.y })); const maxGridX = Math.ceil(canvas.width / VISUAL_GRID_SIZE); const maxGridY = Math.ceil(canvas.height / VISUAL_GRID_SIZE); for (let gy = 0; gy < maxGridY; gy++) { for (let gx = 0; gx < maxGridX; gx++) { if (isPointInPolygon(gx + 0.5, gy + 0.5, gridOutlinePoints)) { const interpolatedHeight = getInterpolatedHeight(gx + 0.5, gy + 0.5); if (interpolatedHeight !== null) { const heightDifference = maxHeight - interpolatedHeight; if (heightDifference > 0) { totalVolumeMM3 += heightDifference * cellAreaMM2; } } else { totalVolumeMM3 += maxHeight * cellAreaMM2; } } } } const totalVolumeLiters = totalVolumeMM3 / 1000000; return totalVolumeLiters; }

  // --- Update and Redraw ---

  function updateCalculations() { const area = calculateArea(); const volume = calculateVolume(); areaDisplay.textContent = area.toFixed(2); volumeDisplay.textContent = volume.toFixed(2); }

  function redrawCanvas() {
    if (!canvas || !ctx) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // --- Draw Visualizations (Layered) ---
    if (activeVisualizations.has('heightMap')) { if (isOutlineClosed && measurementPoints.filter(p => p.height !== undefined && p.height !== null).length > 0) { drawHeightMap(); } }
    if (activeVisualizations.has('depthNumbers')) { if (isOutlineClosed && measurementPoints.filter(p => p.height !== undefined && p.height !== null).length > 0) { drawDepthNumbers(); } }
    if (activeVisualizations.has('topographicMap')) { if (isOutlineClosed && measurementPoints.filter(p => p.height !== undefined && p.height !== null).length > 0) { drawTopographicMap(); } }

    // --- Draw Core Elements ---
    drawGrid(); drawOrigin(); drawOutline(); drawMeasurementPoints();
    drawRubberBandLine(); drawHoverHighlight();
  }

  // --- Floating Input Logic --- (No changes)
  function showFloatingInput(canvasX, canvasY, point = null) { selectedMeasurementPoint = point; heightInput.value = (point && point.height !== undefined) ? point.height : ''; const inputX = canvasRect.left + canvasX + 10; const inputY = canvasRect.top + canvasY + 10; floatingInputDiv.style.left = `${inputX}px`; floatingInputDiv.style.top = `${inputY}px`; floatingInputDiv.style.display = 'block'; heightInput.focus(); heightInput.select(); redrawCanvas(); }
  function hideFloatingInput() { if (floatingInputDiv.style.display !== 'none') { if (selectedMeasurementPoint) { const newHeight = parseInt(heightInput.value, 10); if (!isNaN(newHeight)) selectedMeasurementPoint.height = newHeight; else if (heightInput.value.trim() === '') selectedMeasurementPoint.height = undefined; updateCalculations(); } selectedMeasurementPoint = null; floatingInputDiv.style.display = 'none'; redrawCanvas(); } }
  function handleFloatingInputKey(event) { if (event.key === 'Enter') { event.preventDefault(); hideFloatingInput(); } else if (event.key === 'Escape') { selectedMeasurementPoint = null; floatingInputDiv.style.display = 'none'; redrawCanvas(); } }

  // --- Event Handlers ---

  gridSpacingInput.addEventListener('change', () => { const newScale = parseInt(gridSpacingInput.value, 10); if (newScale >= 1) { gridScale = newScale; updateCalculations(); if (origin && hoverGridPoint) { const realCoords = gridToReal(hoverGridPoint.x, hoverGridPoint.y); cursorCoordsDisplay.textContent = `(${realCoords.x}, ${realCoords.y}) mm`; } else if (origin) { cursorCoordsDisplay.textContent = `(Hover over grid)`; } } else { gridSpacingInput.value = gridScale; } });

  // Tool Palette Listener
  toolPalette.addEventListener('click', (e) => { const button = e.target.closest('button'); if (button && button.dataset.mode) { const newMode = button.dataset.mode; if (newMode !== mode) { mode = newMode; toolPalette.querySelectorAll('button').forEach(btn => { btn.classList.remove('active'); }); button.classList.add('active'); selectedMeasurementPoint = null; hideFloatingInput(); hoverGridPoint = null; hoverSpecificPoint = null; redrawCanvas(); } } });

  // Visualization Checkbox Listener
  visualizationCheckboxes.forEach(checkbox => { checkbox.addEventListener('change', (e) => { const vizKey = e.target.value; if (e.target.checked) { activeVisualizations.add(vizKey); } else { activeVisualizations.delete(vizKey); } redrawCanvas(); }); });

  interpolationSelect.addEventListener('change', (e) => { interpolationMethod = e.target.value; updateCalculations(); redrawCanvas(); });

  window.addEventListener('mousemove', (e) => { if (!canvas) return; const pos = getMousePos(e); lastMousePos = { x: pos.x, y: pos.y }; if (draggingPoint) { const currentGridPos = canvasToGrid(pos.snappedX, pos.snappedY); if (currentGridPos && (currentGridPos.x !== draggingPoint.x || currentGridPos.y !== draggingPoint.y)) { draggingPoint.x = currentGridPos.x; draggingPoint.y = currentGridPos.y; updateCalculations(); } const realCoords = gridToReal(currentGridPos.x, currentGridPos.y); cursorCoordsDisplay.textContent = origin ? `(${realCoords.x}, ${realCoords.y}) mm` : `(Origin not set)`; canvas.style.cursor = 'grabbing'; redrawCanvas(); return; } else { canvas.style.cursor = 'crosshair'; } isMouseOverCanvas = (e.target === canvas); let needsRedraw = false; if (isMouseOverCanvas) { const gridCoords = canvasToGrid(pos.snappedX, pos.snappedY); const realCoords = gridToReal(gridCoords.x, gridCoords.y); cursorCoordsDisplay.textContent = origin ? `(${realCoords.x}, ${realCoords.y}) mm` : `(Origin not set)`; const currentHoverGridPoint = gridCoords; if (!hoverGridPoint || hoverGridPoint.x !== currentHoverGridPoint.x || hoverGridPoint.y !== currentHoverGridPoint.y) { hoverGridPoint = currentHoverGridPoint; needsRedraw = true; } if (mode === 'selectMove') needsRedraw = true; if (mode === 'drawOutline' && !isOutlineClosed && outlinePoints.length > 0) needsRedraw = true; } else { if (hoverGridPoint) { hoverGridPoint = null; needsRedraw = true; } cursorCoordsDisplay.textContent = origin ? `(Off Canvas)` : `(Origin not set)`; } if (needsRedraw) redrawCanvas(); });
  canvas.addEventListener('mouseleave', () => { isMouseOverCanvas = false; if (hoverGridPoint || hoverSpecificPoint) { hoverGridPoint = null; hoverSpecificPoint = null; redrawCanvas(); } lastMousePos = null; });
  canvas.addEventListener('mouseenter', (e) => { isMouseOverCanvas = true; });
  canvas.addEventListener('mousedown', (e) => { if (e.button !== 0) return; const pos = getMousePos(e); let foundPointToDrag = null; if (mode === 'selectMove') { const measurement = findMeasurementPointNear(pos.x, pos.y); if (measurement) foundPointToDrag = measurement.point; else { const outlineVtx = findOutlineVertexNear(pos.x, pos.y); if (outlineVtx) foundPointToDrag = outlineVtx.point; else if (isNearOrigin(pos.x, pos.y)) foundPointToDrag = origin; } } else if (mode === 'selectOrigin') { if (isNearOrigin(pos.x, pos.y)) foundPointToDrag = origin; } else if (mode === 'drawOutline') { const clickedVertexData = findOutlineVertexNear(pos.x, pos.y); if (clickedVertexData) foundPointToDrag = clickedVertexData.point; } else if (mode === 'selectMeasurements') { const clickedMeasurementData = findMeasurementPointNear(pos.x, pos.y); if (clickedMeasurementData) foundPointToDrag = clickedMeasurementData.point; } if (foundPointToDrag) { draggingPoint = foundPointToDrag; dragStartCoords = { x: pos.x, y: pos.y }; hideFloatingInput(); if (mode === 'selectMeasurements') selectedMeasurementPoint = null; canvas.style.cursor = 'grabbing'; redrawCanvas(); } });
  window.addEventListener('mouseup', (e) => { if (e.button !== 0) return; if (draggingPoint) { const pos = getMousePos(e); const finalGridPos = canvasToGrid(pos.snappedX, pos.snappedY); if (finalGridPos) { draggingPoint.x = finalGridPos.x; draggingPoint.y = finalGridPos.y; } draggingPoint = null; dragStartCoords = null; updateCalculations(); canvas.style.cursor = 'crosshair'; redrawCanvas(); } });
  canvas.addEventListener('click', (e) => { const pos = getMousePos(e); const gridCoords = canvasToGrid(pos.snappedX, pos.snappedY); if (!gridCoords || typeof gridCoords.x !== 'number' || typeof gridCoords.y !== 'number') return; if (dragStartCoords && (Math.abs(pos.x - dragStartCoords.x) > 5 || Math.abs(pos.y - dragStartCoords.y) > 5)) return; const clickedMeasurementData = findMeasurementPointNear(pos.x, pos.y); if (floatingInputDiv.style.display === 'block' && (!clickedMeasurementData || !selectedMeasurementPoint || clickedMeasurementData.point.id !== selectedMeasurementPoint.id)) { hideFloatingInput(); } if (mode === 'selectOrigin') { if (!isNearOrigin(pos.x, pos.y)) { origin = gridCoords; updateCalculations(); redrawCanvas(); } } else if (mode === 'drawOutline') { if (!isOutlineClosed) { const clickedVertexData = findOutlineVertexNear(pos.x, pos.y); if (outlinePoints.length >= 3 && clickedVertexData && clickedVertexData.point === outlinePoints[0]) { isOutlineClosed = true; updateCalculations(); redrawCanvas(); return; } const lastPoint = outlinePoints[outlinePoints.length - 1]; if (!lastPoint || lastPoint.x !== gridCoords.x || lastPoint.y !== gridCoords.y) { outlinePoints.push(gridCoords); updateCalculations(); redrawCanvas(); } } else { console.log("Outline already closed."); } } else if (mode === 'selectMeasurements') { if (clickedMeasurementData) { showFloatingInput(pos.snappedX, pos.snappedY, clickedMeasurementData.point); } else { const newPoint = { id: `M${nextMeasurementId++}`, x: gridCoords.x, y: gridCoords.y, height: undefined }; measurementPoints.push(newPoint); showFloatingInput(pos.snappedX, pos.snappedY, newPoint); } } /* selectMove mode has no click action */ });
  canvas.addEventListener('contextmenu', (e) => { e.preventDefault(); const pos = getMousePos(e); if (mode === 'selectMeasurements') { const clickedMeasurementData = findMeasurementPointNear(pos.x, pos.y); if (clickedMeasurementData) { if (selectedMeasurementPoint && selectedMeasurementPoint.id === clickedMeasurementData.point.id) hideFloatingInput(); measurementPoints.splice(clickedMeasurementData.index, 1); updateCalculations(); redrawCanvas(); return; } } else if (mode === 'drawOutline') { const clickedVertexData = findOutlineVertexNear(pos.x, pos.y); if (clickedVertexData) { outlinePoints.splice(clickedVertexData.index, 1); if (outlinePoints.length < 3 || isOutlineClosed) { isOutlineClosed = false; } updateCalculations(); redrawCanvas(); return; } } });
  document.addEventListener('click', (e) => { if (floatingInputDiv.style.display === 'block') { if (!canvas.contains(e.target) && !floatingInputDiv.contains(e.target) && !controlsPanel.contains(e.target)) hideFloatingInput(); } });
  heightInput.addEventListener('keydown', handleFloatingInputKey);
  function getStateAsJson() { const state = { gridScale: gridScale, origin: origin, outlinePoints: outlinePoints, measurementPoints: measurementPoints, isOutlineClosed: isOutlineClosed, nextMeasurementId: nextMeasurementId, interpolationMethod: interpolationMethod, activeVisualizations: Array.from(activeVisualizations) /* Convert Set to Array */ }; return JSON.stringify(state, null, 2); }
  function loadStateFromJson(jsonString) { try { const state = JSON.parse(jsonString); if (!state || typeof state !== 'object') throw new Error("Invalid JSON data."); if (typeof state.gridScale !== 'number' || !Array.isArray(state.outlinePoints) || !Array.isArray(state.measurementPoints)) throw new Error("Missing or invalid core state properties."); gridScale = state.gridScale; origin = state.origin || null; outlinePoints = state.outlinePoints; measurementPoints = state.measurementPoints; isOutlineClosed = state.isOutlineClosed || false; nextMeasurementId = state.nextMeasurementId || (measurementPoints.length > 0 ? Math.max(...measurementPoints.map(p => parseInt(p.id.substring(1), 10))) + 1 : 0); interpolationMethod = state.interpolationMethod || 'nearestNeighbor'; activeVisualizations = new Set(state.activeVisualizations || []); /* Load Set from Array */ gridSpacingInput.value = gridScale; mode = 'selectMove'; /* Reset to default mode after load */ toolPalette.querySelectorAll('button').forEach(btn => { btn.classList.toggle('active', btn.dataset.mode === mode); }); /* Update active tool button */ visualizationCheckboxes.forEach(cb => { cb.checked = activeVisualizations.has(cb.value); }); interpolationSelect.value = interpolationMethod; selectedMeasurementPoint = null; draggingPoint = null; hoverGridPoint = null; hoverSpecificPoint = null; hideFloatingInput(); resizeCanvas(); jsonImportText.value = ''; alert("State imported successfully!"); } catch (error) { console.error("Failed to import state:", error); alert(`Error importing state: ${error.message}`); } }
  exportJsonButton.addEventListener('click', () => { const jsonState = getStateAsJson(); navigator.clipboard.writeText(jsonState).then(() => alert('State copied to clipboard!')).catch(err => { console.error('Failed to copy state: ', err); alert('Error copying state. See console.'); }); });
  importJsonButton.addEventListener('click', () => { const jsonString = jsonImportText.value.trim(); if (jsonString) loadStateFromJson(jsonString); else alert('Please paste JSON state into the text area first.'); });
  clearAllButton.addEventListener('click', () => { if (confirm("Are you sure you want to clear all data?")) { gridScale = 100; origin = null; outlinePoints = []; measurementPoints = []; nextMeasurementId = 0; selectedMeasurementPoint = null; draggingPoint = null; isOutlineClosed = false; hoverGridPoint = null; hoverSpecificPoint = null; lastMousePos = null; isMouseOverCanvas = false; interpolationMethod = 'nearestNeighbor'; activeVisualizations.clear(); gridSpacingInput.value = gridScale; mode = 'selectMove'; toolPalette.querySelectorAll('button').forEach(btn => { btn.classList.toggle('active', btn.dataset.mode === mode); }); visualizationCheckboxes.forEach(cb => cb.checked = false); interpolationSelect.value = interpolationMethod; jsonImportText.value = ''; hideFloatingInput(); updateCalculations(); redrawCanvas(); cursorCoordsDisplay.textContent = '(Origin not set)'; } });

  // --- Initial Setup & Resize ---
  function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; canvasRect = canvas.getBoundingClientRect(); redrawCanvas(); updateCalculations(); }
  resizeCanvas(); window.addEventListener('resize', resizeCanvas);

</script>

</body>
</html>
